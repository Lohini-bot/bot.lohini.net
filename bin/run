#!/bin/bash

### BEGIN INIT INFO
# Provides:          lohini-bot-worker
# Required-Start:    $network $remote_fs $syslog
# Required-Stop:     $network $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Lohini Bot worker
### END INIT INFO

. /etc/rc.conf
. /etc/rc.d/functions

NAME="lohini-bot-worker"
DESC="Lohini Bot worker"

PHP=`which php`
SSD=`which start-stop-daemon`
WORKER_DIR="$( cd "$( dirname "$0" )" && pwd )"
WORKER="$WORKER_DIR/worker.php"
DAEMON_OPTS=" $WORKER"
PIDFILE="/run/$NAME.pid"

test -x $WORKER || exit 0
test -x $PHP || exit 0

pidofproc () {
	local pidfile line i pids= status specified pid
	pidfile=
	specified=

	OPTIND=1
	while getopts p: opt ; do
		case "$opt" in
			p)  pidfile="$OPTARG"; specified=1;;
		esac
	done
	shift $(($OPTIND - 1))

	base=${1##*/}
	if [ ! "$specified" ]; then
		pidfile="/var/run/$base.pid"
	fi

	if [ -n "${pidfile:-}" -a -r "$pidfile" ]; then
		read pid < "$pidfile"
		if [ -n "${pid:-}" ]; then
			if $(kill -0 "${pid:-}" 2> /dev/null); then
				echo "$pid"
				return 0
			elif ps "${pid:-}" >/dev/null 2>&1; then
				echo "$pid"
				return 0 # program is running, but not owned by this user
			else
				return 1 # program is dead and /var/run pid file exists
			fi
		fi
	fi
	if [ -x /bin/pidof -a ! "$specified" ]; then
		status="0"
		/bin/pidof -o %PPID -x $1 || status="$?"
		if [ "$status" = 1 ]; then
			return 3 # program is not running
		fi
		return 0
	fi
	return 4 # Unable to determine status
}

# Return LSB status
status_of_proc () {
	local pidfile daemon name status

	pidfile=
	OPTIND=1
	while getopts p: opt ; do
		case "$opt" in
			p)  pidfile="$OPTARG";;
		esac
	done
	shift $(($OPTIND - 1))

	if [ -n "$pidfile" ]; then
		pidfile="-p $pidfile"
	fi
	daemon="$1"
	name="$2"

	status="0"
	pidofproc $pidfile $daemon >/dev/null || status="$?"
	if [ "$status" = 0 ]; then
		stat_append "$name is running"
		stat_started
		return 0
	elif [ "$status" = 4 ]; then
		stat_append "could not access PID file for $name"
		stat_fail
		return $status
	else
		stat_append "$name is not running"
		stat_stopped
		return $status
	fi
}

stat_started () {
	deltext
	printf "${C_OTHER}[${C_DONE}STARTED${C_OTHER}]${C_CLEAR}\n"
}

stat_stopped () {
	deltext
	printf "${C_OTHER}[${C_FAIL}STOPPED${C_OTHER}]${C_CLEAR}\n"
}

start_worker () {
	STATUS=0
	# Check to see if it's already started...
	if [ -e /var/run/$NAME.pid ]; then
		stat_append "Already running (PID file exists)"
		stat_die
	else
		$SSD --start --background --quiet \
			--make-pidfile --pidfile $PIDFILE --chdir $WORKER_DIR --chuid lopo \
			--exec $PHP -- $DAEMON_OPTS || STATUS=1
	fi
	if [ "$STATUS" = "0" ]; then
		stat_done
	else
		stat_fail
	fi
}

stop_worker () {
	STATUS=0

	if [ -s "$PIDFILE" ]; then
		$SSD --stop --quiet --pidfile $PIDFILE || STATUS=1
		rm -f $PIDFILE
		stat_done
	else
		stat_append "  $NAME is not running."
		stat_fail
	fi
}

case "$1" in
	start)
		stat_busy "Starting $DESC"
		start_worker
		exit ${STATUS:-0}
	;;
	stop)
		stat_busy "Stopping $DESC"
		stop_worker
		exit ${STATUS:-0}
	;;
	restart)
		stat_busy "Restarting $DESC"
		stop_worker
		sleep 2
		start_worker
		exit ${STATUS:-0}
	;;
	status)
		STATUS=0
		stat_busy
		status_of_proc -p $PIDFILE $NAME "$DESC" || STATUS=1
		exit $STATUS
	;;
	*)
		echo "Usage: $0 {start|stop|restart|status}" >&2
		exit 1
	;;
esac

exit 0
